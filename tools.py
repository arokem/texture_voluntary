import os
import time

import numpy as np
import wx

from psychopy import core, visual, event, gui
from psychopy.sound import Sound as Sound

from matplotlib.mlab import window_hanning,csv2rec
import matplotlib.pyplot as plt
from scipy.optimize import leastsq

#User input GUI:
class GetFromGui(wx.Dialog):
    """ Allows user to set input parameters of ss through a simple GUI"""    
    def __init__(self, parent, id, title):
        wx.Dialog.__init__(self, parent, id, title, size=(280,220))
        # Add text label
        wx.StaticText(self, -1, 'Subject ID:', pos=(10,20))
        # Add the subj id text box:
        self.textbox1 = wx.TextCtrl(self, -1, pos=(100,18), size=(150, -1))

        # Add text label
        wx.StaticText(self, -1, 'SOA (msec):', pos=(10, 50))
        # Add the SOA text box:
        self.textbox2 = wx.TextCtrl(self, -1, pos=(100, 50), size=(150, -1))

        self.rb_demo = wx.RadioButton(self, -1, 'demo', (100, 100),
                                  style=wx.RB_GROUP)
        # Add OK/Cancel buttons
        wx.Button(self, 1, 'Done', (60, 150))
        wx.Button(self, 2, 'Quit', (150, 150))
        
        # Bind button press events to class methods for execution
        self.Bind(wx.EVT_BUTTON, self.OnDone, id=1)
        self.Bind(wx.EVT_BUTTON, self.OnClose, id=2)
        self.Centre()
        self.ShowModal()        

    # If "Done" is pressed, set important values and close the window
    def OnDone(self,event):

        self.success = True
        self.subject = self.textbox1.GetValue()
        choose_soa = self.textbox2.GetValue()
        
        if choose_soa:
            self.SOA = choose_soa
        else:
            self.SOA = 100

        if self.rb_demo.GetValue():
            self.demo=True
        else:
            self.demo=False

        self.Close()

    # If "Quit" is pressed" , toggle failure and close the window
    def OnClose(self, event):
        self.success = False
        self.Close()


class Params(object):
    """
    The Params class stores all of the parameters needed during the execution
    of ss_run.

    Once a parameter is set, it is protected and cannot be changed, unless it
    is explicitely removed from the _dont_touch variable. 

    Some parameters are set upon initialization from the file 'ss_params.py'

    Others are set through a gui which is generated by the method set_by_gui
    
    """
    def __init__(self, p_file='params'):
        """
        Initializer for the params object.

        Parameters
        ----------

        p_file: string, the name of a parameter file, defaults to 'ss_params'

        """
        self._dont_touch = []
        #The following params are read in from a file with dict p.
        im = __import__(p_file)
        for k in im.p.keys():
            self.__setattr__(k,im.p[k])
            self._dont_touch.append(k)

    def __setattr__(self,name,value):
        """
        
        Overloading __setattr__, such that attributes cant be changed once they
        are set, unless they are explicitely removed from the _dont_touch list.

        """

        if name == '_dont_touch':
            super.__setattr__(self,name,value) 
        elif name in self._dont_touch:
            raise ValueError("Parameter %s is protected, please don't touch!"%name)
        else:
            super.__setattr__(self,name,value)
            self._dont_touch.append(name)

    def set_by_gui(self):
        """
        Set additional parameters through a wx GUI object. The wx app needs to
        be started and set in the main loop
        
        """

        # Use the GetFromGui class (below):
        user_choice = GetFromGui(None, -1, 'Params')
        # success is achieved if the user presses 'done': 
        if user_choice.success:                
                user_params = {
                    "subject" : user_choice.subject,
                    "texture_dur" : float(user_choice.SOA)/1000.,
                    "demo": user_choice.demo,
                    }
        else:
            user_choice.Destroy()
            raise ValueError("Program stopped by user")
        # Stop execution of the window
        user_choice.Destroy()
        
        for k in user_params.keys():
            self.__setattr__(k,user_params[k])

    def save(self,f,open_and_close=False):
        """

        This saves the parameters to a text file.

        Takes as an input an already opened file object and returns it in the
        end. Does not open or close the file, unless the variable
        open_and_close is set to True, in which case, the input should be a
        file-name, not a file object

        f is returned either way
        """

        if open_and_close:
            f = file(file_name,'w')
            for k in self.__dict__.keys():
                if k[0]!='_': #Exclude 'private' variables ('_dont_touch')
                    f.write('# %s : %s \n'%(k,self.__dict__[k]))
            f.close()

        else:
            for k in self.__dict__.keys():
                if k[0]!='_': #Exclude 'private' variables ('_dont_touch')
                    f.write('# %s : %s \n'%(k,self.__dict__[k]))
        return f
    
def sound_freq_sweep(startFreq, endFreq, duration, samples_per_sec=None):
    """   
    Creates a normalized sound vector (duration seconds long) where the
    frequency sweeps from startFreq to endFreq (on a log2 scale).

    Parameters
    ----------

    startFreq: float, the starting frequency of the sweep in Hz
    
    endFreq: float, the ending frequency of the sweep in Hz

    duration: float, the duration of the sweep in seconds

    samples_per_sec: float, the sampling rate, defaults to 44100 


    """
    if samples_per_sec is None:
        samples_per_sec = 44100

    time = np.arange(0,duration*samples_per_sec)

    if startFreq != endFreq:
        startFreq = np.log2(startFreq)
        endFreq = np.log2(endFreq)
        freq = 2**np.arange(startFreq,endFreq,(endFreq-startFreq)/(len(time)))
        freq = freq[:time.shape[0]]
    else:
        freq = startFreq
    
    snd = np.sin(time*freq*(2*np.pi)/samples_per_sec)

    # window the sound vector with a 50 ms raised cosine
    numAtten = np.round(samples_per_sec*.05);
    # don't window if requested sound is too short
    if len(snd) >= numAtten:
        snd[:numAtten/2] *= window_hanning(np.ones(numAtten))[:numAtten/2]
        snd[-(numAtten/2):] *= window_hanning(np.ones(numAtten))[-(numAtten/2):]

    # normalize
    snd = snd/np.max(np.abs(snd))

    return snd

def compound_sound(freqs, duration, samples_per_sec=None):
    """
    Generate a sound made out of several frequencies

    Parameters
    ---------
    freqs: list
        A list of frequencies to be included in the 
    
    """
    if samples_per_sec is None:
        samples_per_sec = 44100

    time = np.arange(0,duration*samples_per_sec)
    snd = np.zeros_like(time)
    
    for f in freqs:
        snd =  snd + np.sin(time*f*(2*np.pi)/samples_per_sec)

    # window the sound vector with a 50 ms raised cosine
    numAtten = np.round(samples_per_sec*.05);
    # don't window if requested sound is too short
    if len(snd) >= numAtten:
        snd[:numAtten/2] *= window_hanning(np.ones(numAtten))[:numAtten/2]
        snd[-(numAtten/2):] *= window_hanning(np.ones(numAtten))[-(numAtten/2):]

    # normalize
    snd = snd/np.max(np.abs(snd))

    return snd
    
def start_data_file(subject_id):

    """Start a file object into which you will write the data, while making
    sure not to over-write previously existing files """
    
    #Check the data_file:
    
    list_data_dir = os.listdir('./data')

    i=1
    this_data_file = '%s_%s_%s_texture.csv'%(subject_id,
                                                time.strftime('%m%d%Y'),i)

    #This makes sure that you don't over-write previous data:
    while this_data_file in list_data_dir:
        i += 1
        this_data_file='%s_%s_%s_texture.csv'%(subject_id,
                                                  time.strftime('%m%d%Y'),i)
        
    #Open the file for writing into:
    f = file('./data/%s'%this_data_file,'w')

    #Write some header information
    f.write('# Time : %s#\n'%(time.asctime()))

    return f

def save_data(f,*arg):

    for a in arg[0:-1]:
        f.write('%s,'%a)

    #Don't put a comma after the last one:
    f.write('%s \n'%arg[-1])
    
    return f

class Text(object):

    """
    A class for showing text on the screen until a key is pressed 
    """

    def __init__ (self,win,text='Press a key to continue',**kwargs):
        """
        
        Will do the default thing(show 'text' in white on gray background),
        unless you pass in kwargs, which will just go through to
        visual.TextStim (see docstring of that class for more details)

        keys: list. The keys to which you listen for input
        """

        self.win = win
        
        self.text = visual.TextStim(win,text=text,**kwargs)
        
    
    def __call__(self,duration=np.inf):
        """
        Text is shown to the screen, until a key is pressed or until duration
        elapses (default = inf)
        
        """

        clock = core.Clock()
        t=0
        while t<duration: #Keep going for the duration
            t=clock.getTime()

            self.text.draw()
            self.win.flip()

            for key in event.getKeys():
                if key:
                    return

def get_data(file_name):
    file_read = file(file_name,'r')
    l = file_read.readline()
    p = {} #This will hold the params
    l = file_read.readline()
    data_rec = []
    
    if l=='':
        return p,l,data_rec

    while l[0]=='#':
        try:
            p[l[1:l.find(':')-1]]=float(l[l.find(':')+1:l.find('\n')]) 

        #Not all the parameters can be cast as float (the task and the
        #subject): 
        except:
            p[l[2:l.find(':')-1]]=l[l.find(':')+1:l.find('\n')]

        l = file_read.readline()

    try:
        data_rec = csv2rec(file_name)
    except ValueError:
        p = []
    
    return p,l,data_rec
